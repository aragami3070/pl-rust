\documentclass[a4paper, 10pt]{extarticle}

\usepackage{preamble}

\begin{document}
\title{Задание \textnumero 31\\ Traits }
\author{}
\date{}
\maketitle

\section{Общая постановка задачи}

\begin{awesomeblock}[blue!70!black]{2pt}{\faTasks}{blue!70!black}
    В данном задании Вам предстоит объявить некоторый трейт (trait) и описать несколько его реализаций. В шаблонах заданий уже могут быть описаны некоторые типы, для которых необходимо реализовать данный трейт. Для некоторых типов требуется дописать ограничения (трейты).
\end{awesomeblock}

\begin{awesomeblock}[blue!70!black]{2pt}{\faTasks}{blue!70!black}
    Шаблоны задания могут содержать подключение некоторых дополнительных структур данных и функций, необходимых для одного из возможных решений. 
    
    Вы можете предложить другое решение, не использующее что-то из представленного. В таком случае необходимо удалить подключения неиспользуемого функционала.
\end{awesomeblock}

\begin{awesomeblock}[blue!70!black]{2pt}{\faTasks}{blue!70!black}
    В файле \mintinline{bat}"tests.rs", расположенном в папке \mintinline{bat}"test" находится минимальный набор тестов, которые помогут проверить частичную правильность решения на простом наборе входных данных.

    Для запуска тестов стоит воспользоваться командой \mintinline{bat}"cargo test".
\end{awesomeblock}

\begin{importantblock}
    Код программы должен быть корректно отформатирован. При наличии небрежностей форматирования преподаватель оставляет за собой право  не проверять решение и оценить его в 0 баллов. 

    Автоматически оформить решение можно с помощью команды \mintinline{bat}"cargo fmt".
\end{importantblock}

\begin{awesomeblock}[blue!70!black]{2pt}{\faFile}{blue!70!black}
    В качестве решения задания на портал должен быть загружен 1 файл "--- архив папки с проектом с именем \mintinline{bat}"task31-NN", где вместо \smlinline"NN" "--- номер вашего варианта.
    
    Архив должен включать в себя только исходные файлы и файлы проекта. Не следует включать в архив артефакты сборки (папку \verb|target|).
\end{awesomeblock}

\section{Ограничения}

\begin{importantblock}
    Не следует изменять предоставленный шаблон в части наименования трейтов, типов и заранее объявленных или описанных методов. Однако можно добавлять и изменять любые методы, трейты и типы при наличии необходимости в этом без влияния на функционал.
\end{importantblock}

\begin{importantblock}
    Повторение кода должно быть по возможности минимизировано.
\end{importantblock}

\begin{importantblock}
Не следует делать предположений насчёт задания, не сформулированных явно в условии. Если возникают сомнения "--- задайте вопрос на форуме <<Язык Rust>>.
\end{importantblock}


%\newpage
\section{Пример задания}
% \noindent\textsc{Задание:}

\begin{tsk}[Пример 1. <<Зоопарк>>]
    Опишите трейт \verb|Say| с единственным методом для вывода в консоль фиксированной строки (голос животного). Опишите реализацию для класса \verb|Dog| (говорит <<woof-woof>>) и \verb|Cat| (говорит <<meow>>). Напишите функцию, которая будет заставлять любое говорящее животное дважды издавать звук.
\end{tsk}

\section{Пример решения}
\begin{minted}[]{rust}
#![forbid(unsafe_code)]

struct Cat;
struct Dog;

trait Say {
  fn say(&self);
}

impl Say for Cat {
  fn say(&self) { println!("meow") }
}

impl Say for Dog {
  fn say(&self) { println!("woof-woof") }
}

fn force_say<T: Say>(t: &T) {
  t.say();
  t.say();
}
\end{minted}

% Содержимое файла \verb"task27-00.scala":
% \inputminted[style= native]{scala}{task27-00.scala}

Текст примера (файл \verb"task31-00.rs") можно загрузить с портала.

\section{Задания}

\begin{tsk}[Логгер]
    Опишите трейт \verb|Logger| с методами для логирования сообщений разного уровня: DEBUG, INFO, WARN, ERROR, FATAL. Данный trait должен быть реализован двумя способами: отображение сообщений в консоли и сохранение сообщений в файл. Сообщения должны иметь формат: \verb|[ДАТА СООБЩЕНИЯ] [ТИП СООБЩЕНИЯ] текст сообщения|. В случае записи в файл перед сообщением необходимо выводить текущее время, а каждое новое сообщение должно начинаться с новой строки.

    Опишите функцию, принимающую на вход ссылку на вектор элементов произвольного типа (но для объектов должно быть определено приведение к строке и сравнение на равенство, см. трейты \verb|ToString| и \verb|Eq|), и ссылку на объект типа, реализующего трейт \verb|Logger|. Перед обработкой вектора в лог необходимо внести INFO сообщение <<Start processing>>. В случае нахождения одинаковых последовательных элементов нужно внести WARN сообщение <<Found repeat \verb|x|>>, подставляя найденное повторяющееся значение (сколько раз элемент не повторялся бы последовательно, в логе должно оказаться лишь одно упоминание). В конце обработки внести INFO сообщение <<End processing>>.

    Для записи в файл используйте модуль \href{https://doc.rust-lang.org/std/fs/index.html}{fs}, с примерами работы с ним можно ознакомиться \href{https://metanit.com/rust/tutorial/14.2.php}{здесь}. Для осуществления записи в конец файла изучите \href{https://doc.rust-lang.org/std/fs/struct.OpenOptions.html}{данный} раздел документации. Чтобы получить текущее системное время в виде строки, используйте \mintinline{rust}"Local::now().to_string()", необходимый крейт уже подключен.
\end{tsk}

\begin{tsk}[IP"=фильтр]
    Опишите трейт \verb|Filter| с единственным методом для определения допустимости IP"=адреса по некоторому правилу (IP"=адресу сопоставляется bool). Необходимо описать реализацию для фильтрации по принципу <<черного списка>> (считаем адрес недопустимым только тогда, когда он есть в списке), <<белого списка>> (считаем адрес допустимым только тогда, когда он входит в список), по принадлежности подсети (заданы маска подсети и адрес подсети, адрес допустим только тогда, когда принадлежит подсети). Структура для хранения IP"=адреса уже описана. В задании учитываем только IPv4"=адреса.

    Реализуйте функцию \verb|ip_collection_filter|, принимающую на вход коллекцию (не обязательно вектор) IP"=адресов и объект типа, реализующего трейт \verb|Filter|. Функция должна составлять новую коллекцию из допустимых адресов. Будем работать только с такими коллекциями, для которых доступен итератор и которые содержат IP"=адреса (используйте ограничение трейтами \verb|IntoIterator<Item = ...>| и \verb|FromIterator<...>|, где вместо ... можно подставить тип, содержащийся в коллекции).

    Напомним, что для определения принадлежности IP"=адреса подсети необходимо выполнить побитовое И между IP"=адресом и маской подсети и сравнить результат с адресом необходимой подсети.
\end{tsk}

\begin{tsk}[Валидатор]
    Опишите трейт \verb|FormField| с единственным методом для валидации данных, который должен возвращать \verb|bool|. Реализуйте данный трейт в классах для номера телефона, пароля и адреса электронной почты.
    
    Реализуйте функцию, которая будет принимать на вход коллекцию (не обязательно вектор) из валидируемых типов, и возвращать вектор из невалидных значений. Будем работать только с такими коллекциями, по которым можно итерироваться и которые содержат валидируемые типы (используйте ограничение следующим трейтом: \verb|IntoIterator<Item = ...>|, где вместо ... можно подставить тип, содержащийся в коллекции).

    Номер телефона, пароль и email будем представлять в виде типа с единственным полем --- строкой. Будем считать номер телефона валидным, если он начинается со знака \verb|+| и далее содержит от 7 до 15 цифр включительно. Будем считать пароль валидным, если его длина находится в пределах от 8 до 32 символов и он содержит символы хотя бы из трех следующих множеств: цифры, заглавные латинские буквы, строчные латинские буквы, спецсимволы (+-/*.,@!). Email адрес упрощенно считаем валидным, если он состоит из разделенных точкой или собакой последовательностей из цифр, латинских букв, знаков нижнего подчеркивания и тире (притом адрес должен содержать ровно один знак @, а справа от @ должна быть хотя бы одна точка).
    
    Не следует использовать регулярные выражения.
\end{tsk}

\begin{tsk}[Парсер таблиц]
    Опишите трейт \verb|Parser| с единственным методом для парсинга табличных данных из файла (на вход поступает строка --- адрес файла), возвращающий обернутый в контейнер \verb|Result| вектор векторов некоторого типа (таблицу), ограниченного трейтом \verb|FromStr| (позволяет преобразование из строки в заданный тип). Для поля ошибки используйте строки. Реализуйте данный трейт для считывания файлов текстовых форматов .csv и .tsv, предназначенных для хранения таблиц. В шаблоне задания представлены типы для файла .csv формата и .tsv формата.

    Формат .tsv будем считать устроенным следующим образом: каждая новая строка таблицы начинается с новой строки в файле, разделение по столбцам осуществляется с помощью символа табуляции. Формат .csv аналогичен .tsv, однако вместо табуляции используется запятая, притом .csv позволяет использовать запятую внутри поля как часть значения (а не разделитель) при обрамлении данного поля в двойные кавычки (см. \href{https://ru.wikipedia.org/wiki/CSV#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80}{пример}).

    О построчном считывании файлов можно почитать \href{https://doc.rust-lang.org/rust-by-example/std_misc/file/read_lines.html}{здесь}. Контейнер \verb|Result| был разобран на лекции.

    В случае проблем с открытием файла или чтением его содержимого программа не должна падать с паникой.
\end{tsk}

\begin{tsk}[Down detector. Бонус 15\%]
    Опишите трейт \verb|Pinger| с единственным методом для проверки доступности сайтов из поступившего на вход вектора строк (URL сайтов), возвращающий вектор пар \verb|(сайт, доступность)|, где второй элемент --- флаг, который принимает true, если сайт доступен, иначе --- false. Необходимо реализовать данный trait в двух структурах: в первой проверка доступности сайта должна производиться через вызов системной утилиты \verb|ping|, а во второй --- через библиотеку Reqwest.

    Опишите трейт \verb|Writer| с единственным методом для вывода произвольной строки. Трейт должен быть реализован в двух типах, в одном вывод должен производится в консоль, а в другом --- в файл.

    Создайте функцию, принимающую вектор адресов сайтов (строки), объект типа, реализующего трейт \verb|Pinger|, и объект типа, реализующего трейт \verb|Writer|, в результате работы которой в консоль или в файл должны быть сначала выведены все доступные сайты, а затем --- все недоступные.

    Об осуществлении вызовов системных утилит (о запуске процессов), можно узнать \href{https://doc.rust-lang.org/std/process/struct.Command.html}{здесь}. В данном задании не требуется делать асинхронную проверку, каждый вызов может быть блокирующим, а потому можно использовать метод \verb|output|, возвращающий \verb|Result<Output>|. \href{https://doc.rust-lang.org/std/io/type.Result.html}{Здесь} можно вспомнить об извлечении значения из \verb|Result|, а \href{https://doc.rust-lang.org/std/process/struct.Output.html}{тут} узнать об устройстве структуры \verb|Output|. О работе с библиотекой Reqwest, а именно ее модулем Blocking, следует узнать из \href{https://docs.rs/reqwest/latest/reqwest/blocking/index.html}{документации}. Будем считать сайт доступным, если в результате запроса возвращен код 200--299. В общем случае результат работы системного \verb|ping| и проверки средствами библиотеки будет отличаться, так как фактически проверяется разное. Для записи в файл используйте модуль \href{https://doc.rust-lang.org/std/fs/index.html}{fs}, с примерами работы с ним можно ознакомиться \href{https://metanit.com/rust/tutorial/14.2.php}{здесь}.
\end{tsk}

\begin{tsk}[Компоненты связности. Бонус 40\%]
    Известно, что классами эквивалентности (по отношению связности) в неориентированных графах являются компоненты связности, а в ориентированных графах --- компоненты сильной связности.

    В задании требуется создать трейт \verb|EqRelation| с методом, возвращающим вектор классов эквивалентности (где каждый класс эквивалентности состоит из элементов исходной структуры) для заданной структуры.

    В шаблоне задания уже описаны структуры для неориентированного графа и для ориентированного. Считаем, что граф может хранить вершины любого типа, для которого определена операция сравнения на равенство. Так как граф в данной реализации хранится в HashMap (вершина => список смежных вершин), то к элементам требуется дополнительное ограничение. Ввиду языковых особенностей в списке смежных вершин предлагается хранить клоны вершин (однако это не считается хорошей практикой: Вы можете переделать структуру, используя умные указатели). Требуется реализовать функцию трейта в этих структурах. Для поиска компонент связности в неориентированном графе следует использовать \href{http://e-maxx.ru/algo/connected_components}{серию DFS}, а для поиска компонент сильной связности в орграфе --- \href{http://e-maxx.ru/algo/strong_connected_components}{алгоритм Косараю}. 
    
    Реализуйте функцию, возвращающую максимальный по размеру класс эквивалентности для переданного по ссылке объекта любого типа, для которого определены классы эквивалентности.
\end{tsk}

\end{document}
