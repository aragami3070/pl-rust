\documentclass[a4paper, 10pt]{extarticle}

\usepackage{preamble}

\begin{document}
\title{Задание \textnumero 29\\ Простые вычисления }
\author{}
\date{}
\maketitle

\section{Общая постановка задачи}

\begin{awesomeblock}[blue!70!black]{2pt}{\faTasks}{blue!70!black}
    В данном задании Вам предстоит познакомиться с базовыми конструкциями языка.
\end{awesomeblock}

\begin{awesomeblock}[blue!70!black]{2pt}{\faTasks}{blue!70!black}
    В файле \mintinline{bat}"tests.rs", расположенном в папке \mintinline{bat}"test" находится минимальный набор тестов, которые помогут проверить корректность решения. Этот же файл демонстрирует примеры работы функций.

    Для запуска тестов стоит воспользоваться командой \mintinline{bat}"cargo test".
\end{awesomeblock}

\begin{importantblock}
    Код программы должен быть корректно отформатирован. При наличии небрежностей форматирования преподаватель оставляет за собой право  не проверять решение и оценить его в 0 баллов. 

    Автоматически оформить решение можно с помощью команды \mintinline{bat}"cargo fmt".
\end{importantblock}

\begin{awesomeblock}[blue!70!black]{2pt}{\faFile}{blue!70!black}
    В качестве решения задания на портал должен быть загружено 1 файл "--- архив папки с проектом с именем \mintinline{bat}"task29-NN", где вместо \smlinline"NN" "--- номер вашего варианта.
    
    Архив должен включать в себя только исходные файлы и файлы проекта. Не следует включать в архив артефакты сборки. 
\end{awesomeblock}

\section{Ограничения}

Несоблюдение следующих правил приведет к снижению оценки за решение.

\begin{importantblock}
    В работе не разрешается подключение дополнительных библиотек за исключением тех, которые представлены в шаблоне задания.
\end{importantblock}

\begin{importantblock}
    Объем выделяемой памяти по возможности не должен зависеть от размера входных данных. Минимальные требования указаны в тексте задания. В случае, если существует более оптимальное решение, то оценка будет снижена на 50\%.
\end{importantblock}

\begin{importantblock}
    Решение должно компилироваться без предупреждений и ошибок. Нарушение этого пункта задания приведёт к снижению оценки на 100\%.
    \end{importantblock}

\begin{importantblock}
    Объем вычислений должен минимально зависеть от размера входных данных. Минимальные требования указаны в тексте задания. В случае, если существует более оптимальное решение, то оценка будет снижена на 50\%.
\end{importantblock}

\begin{importantblock}
Не следует делать предположений насчёт задания, не сформулированных явно в условии. Если возникают сомнения "--- задайте вопрос на форуме <<Язык Rust>>.
\end{importantblock}


%\newpage
\section{Пример задания}
% \noindent\textsc{Задание:}

\begin{tsk}[Пример 1. <<Сталинская сортировка>>]
    Опишите функцию, которая реализует эффективный алгоритм сортировки <<Сталинская сортировка>>. 
    
    Суть алгоритма заключается в удалении элементов, нарушающих отсортированный порядок элементов. Например, массив $[1,4,2,3,6,5,5,7,7]$
    превращается в $[1,4,6,7,7]$
    после выполнения сортировки.

    \textit{Требование по времени}: O(n)

    \textit{Требование по памяти}: O(n) для сохранения нового массива.
\end{tsk}

\section{Пример решения}
Содержимое файла \verb"task29-00.rs"
\begin{minted}[]{rust}
#![forbid(unsafe_code)]

pub fn stalinsort(arr: &[i32]) -> Vec<i32> {
    arr.iter().fold(vec![], |mut acc, a| {
        if acc.last().map_or(true, |x| x < a) {
            acc.push(*a);
        }

        acc
    })
}    
\end{minted}

% Содержимое файла \verb"task27-00.scala":
% \inputminted[style= native]{scala}{task27-00.scala}

Текст примера (файл \verb"task29-00.rs") можно загрузить с портала.

\section{Задания}

\begin{tsk}[Bogosort]
Реализуйте функцию \mintinline{bat}"bogosort", которая принимает срез и на основе него возвращает отсортированный по неубыванию массив с помощью алгоритма Bogosort. 

    \textit{Требование по времени}: без ограничений.

    \textit{Требование по памяти}: O(n) для сохранения нового массива.
\end{tsk}

\begin{tsk}[Перестановки]
    Реализуйте функцию \verb|permutations|, которая принимает вектор и возвращает массив всех возможных перестановок элементов исходного массива.

    \textit{Требование по времени}: без ограничений

    \textit{Требование по памяти}: без ограничений
\end{tsk}

\begin{tsk}[Доминирующий элемент]
    Реализуйте функцию \verb|majority_element|, который возвращает мажоритарный элемент --- элемент, который встречается более чем \(\lfloor \frac{n}{2} \rfloor\) раз. Можно считать, что мажоритарный элемент всегда существует в массиве.

    \textit{Требование по времени}: O(n)

    \textit{Требование по памяти}: O(1)
\end{tsk}

\begin{tsk}[Богатый папа]
    Дан целочисленный массив \texttt{prices}, где \texttt{prices[i]} --- цена данной акции в \( i \)-й день.

    В каждый день вы можете принять решение о покупке и/или продаже акции. В любой момент времени вы можете владеть не более одной акцией. Однако, вы можете купить акцию и сразу же продать её в тот же день.
    
    Реализуйте функцию \verb|max_profit|, которая для заданного массива \verb|prices| возвращает 
    максимальную прибыль, которую можно получить.

    \textit{Требование по времени}: O(n)

    \textit{Требование по памяти}: O(1)
\end{tsk}

\begin{tsk}[Комбинации. Бонус 25\%]
    Реализуйте функцию \verb|combinations|, которая принимает некоторый срез и параметр $k$, и возвращает вектор всех возможных комбинаций из $k$ элементов. Используйте только рекурсию и циклы.

    \textit{Примечание:} индексы элементов комбинаций должны быть в лексикографическом порядке.

    \textit{Требование по времени}: без ограничений

    \textit{Требование по памяти}: без ограничений
\end{tsk}

\begin{tsk}[Удаление дубликатов. Бонус 25\%]
    Дан отсортированный массив, состоящий из целых чисел.

    Реализуйте функцию \verb|remove_duplicates|, которая изменяет исходный массив так, что каждый уникальный элемент встречается не более двух раз, при этом относительный порядок элементов должен сохраняться. Функция должна вернуть значение k "--- число элементов, оставшихся после удаления лишних дубликатов.

    
    \textit{Требование по времени}: O(n)

    \textit{Требование по памяти}: O(1)
\end{tsk}

\begin{tsk}[Газовая станция. Бонус 50\%]
    Дано $n$ заправочных станций вдоль кольцевой дороги, где количество топлива на $i$-й станции задано в массиве \verb|gas[i]|.

    У вас есть автомобиль с неограниченным объёмом бака, и для того чтобы доехать от $i$-й станции до следующей $(i + 1)$-й, требуется \verb|cost[i]| топлива. Путешествие начинается на одной из заправочных станций с пустым баком.
    
    Даны два целочисленных массива \verb|gas| и \verb|cost|. Реализуйте функцию \verb|can_complete_circuit|, которая возвращает позицию, с которой возможно обойти кольцевой маршрут один раз по часовой стрелке, а в противном случае возвращает $-1$. Если решение существует, оно гарантированно является единственным.

    \textit{Требование по времени}: O(n)

    \textit{Требование по памяти}: O(1)
\end{tsk}

\end{document}
